
/* Contract type */
contract VotingType =
  type state
  entrypoint init            : list(string) => state

  entrypoint giveRightToVote : address => unit
  entrypoint delegate        : address => unit
  entrypoint vote            : int => unit
  entrypoint winnerName      : unit => string
  entrypoint currentTally    : unit => list((string, int))

/* Contract implementation */
contract Voting =

  // Types
  record proposal =
    { name : string
    , voteCount : uint
    }

  datatype vote = NotVoted | Voted(int) | Delegated(address)

  record voter =
    { weight : int
    , vote : vote
    }

  record state =
    { chairPerson : address
    , voters : map(address, voter)
    , proposals : list(proposal)
    }

  // Initialization
  entrypoint init(proposalNames: list(string)): state =
    { chairPerson = caller(),
      voters      = Map.empty,
      proposals   = List.map((name) => {name = name, voteCount = 0}, proposalNames) }

  entrypoint initVoter() = { weight = 1, vote = NotVoted}

  entrypoint giveRightToVote(voter: address) =
    require(caller() == state.chairPerson)
    require(!Map.mem(voter, state.voters))
    put(state{ voters = Map.add(voter, initVoter(), state.voters) })

  entrypoint delegateChain(delegate: address) =
    require(delegate != caller()) /* Delegation loop! */
    let voter = Map.find(delegate, state.voters)
    switch(voter.vote)
      Delegated(d) => delegateChain(d)
      _            => delegate

  entrypoint addVote(candidate, weight) =
    let proposal = List.nth(state.proposals, candidate)
    proposal{ voteCount = proposal.voteCount + weight }

  entrypoint delegateVote(delegateTo: address, weight: uint) =
    let voter = Map.find(delegateTo, state.voters)
    switch(voter.vote)
      Voted(vote)  => addVote(vote, weight)
      Delegated(_) => abort("impossible")   // impossible
      NotVoted     => voter{ weight = voter.weight + weight }

  entrypoint delegate(delegateTo: address) =
    require(delegateTo != caller())
    let voter = Map.find(caller(), state.voters)
    require(voter.vote == NotVoted)
    let finalDelegate = delegateChain(delegateTo)
    let voter' = voter{ vote = Delegated(finalDelegate) }
    delegateVote(finalDelegate, voter.weight)

  entrypoint vote(candidate: uint) =
    let voter = Map.find(caller(), state.voters)
    require(voter.vote == NotVoted)
    let voter' = voter{ vote = Voted(candidate) }
    addVote(candidate, voter.weight)

  entrypoint winningProposal'(current, rest) =
    switch(rest)
      []      => current
      p :: ps => winningProposal'(if (p.voteCount > current.voteCount) p else current, ps)

  // const
  entrypoint winningProposal() : proposal =
    switch(state.proposals)
      []      => abort("none")
      p :: ps => winningProposal'(p, ps)

  // const
  entrypoint winnerName() = winningProposal().name

  // const
  entrypoint currentTally() =
    List.map((p) => (p.name, p.voteCount), state.proposals)

