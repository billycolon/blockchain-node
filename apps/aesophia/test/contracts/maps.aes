contract Maps =

  function lookup(k, m : map(string, int)) =
    m[k]

  function mlookup(k, m : map(string, int)) : option(int) =
    Map.lookup(k, m)

  function member(k, m : map(string, int)) = Map.member(k, m)

  function map1() =
    Map.from_list([("foo", 1004), ("bar", 1005)])

  function map2() =
    { ["foo"] = 1004,
      ["bar"] = 1005 }

  function test() =
    [ lookup("bar", update("bar", 1006, map1())),
      lookup("foo", map2()),
      map2() { ["bar"] @ x = x * 2 } ["bar"],
      if(member("foo", map2())) 200 else 0,
      Map.size(map1()) ]

  function delete(k, m : map(string, int)) =
    Map.delete(k, m)

  function empty() : map(string, int) = {}

  function singleton(k, v) : map(string, int) = {[k] = v}

  function update(k, v, m) : map(string, int) =
    m{ [k] = v }

  function modify(k, f, m) : map(string, int) =
    m{ [k] @ x = f(x) }

  type mem = { m : map(int, int), next : int }

  function skip(mem) : mem = mem{ next @ x = x + 1 }

  function alloc(mem, val) : (mem, int) =
    let p = mem.next
    (mem{ m[p] = val, next = p + 1 }, p)

  function nested() =
    alloc({ m = {}, next = 0 }, 42)
