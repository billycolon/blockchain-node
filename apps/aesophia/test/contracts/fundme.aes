/*
 * A simple crowd-funding example
 */
contract FundMe =

  type spend_args = { recipient : address,
                      amount : int }

  type state = { contributions : map(address, int),
                 total         : int,
                 beneficiary   : address,
                 deadline      : int,
                 goal          : int }

  private function abort(err : string) =
    switch(0) 1 => ()

  private function require(b : bool, err : string) =
    if(!b) abort(err)

  private function spend(args : spend_args) =
    raw_spend(args.recipient, args.amount)

  public function init(beneficiary, deadline, goal) : state =
    { contributions = {},
      beneficiary   = beneficiary,
      deadline      = deadline,
      total         = 0,
      goal          = goal }

  private function is_contributor(addr) =
    Map.member(state.contributions, addr)

  public stateful function contribute() =
    require(Chain.block_height < state.deadline, "Deadline has passed")
    let amount =
      switch(Map.lookup(state.contributions, Call.caller))
        None    => Call.value
        Some(n) => n + Call.value
    put(state{ contributions[Call.caller] = amount,
               total = state.total + Call.value })

  public stateful function withdraw() =
    require(Chain.block_height >= state.deadline, "Cannot withdraw before deadline")
    if(Call.caller == state.beneficiary)
      withdraw_beneficiary()
    elif(is_contributor(Call.caller))
      withdraw_contributor()
    else
      abort("Not a contributor or beneficiary")

  private stateful function withdraw_beneficiary() =
    require(state.total >= state.goal, "Project was not funded")
    spend({recipient = state.beneficiary,
           amount    = Contract.balance })
    put(state{ beneficiary = #0 })

  private stateful function withdraw_contributor() =
    require(state.total < state.goal, "Project was funded")
    let to = Call.caller
    spend({recipient = to,
           amount    = state.contributions[to]})
    put(state{ contributions[to] = 0 })

