
contract type Identity = {
  type state;

  let main: int => int;
};

contract Identity = {
  type point('a) = {x:'a, y:'a};
  type cp('a) = {x:'a, y:'a, color:'a};

  //   //if (x==42) 1 else (x*x);
  // };
  //let baz() = {age:3, name:(4:int)};
  //let foo(a,b,c) = c;
  //let rec fac(n) = if((n:int)==0) 1 else (n*fac(n-1))
  //    and main(x) = x::[x+1];
  // let lentr(l) = lent(0,l);
   let rec len(l) =
     switch(l) {
      | [] => 0;
      | x::xs => 1+len(xs);
      };
  // let lent(n,l) =
  //   switch (l) {
  //   | [] => n;
  //   | (x::xs) => lent(n+1,xs);
  //   };
  // let app(a:int,b:int) =
  //    switch(a) {
  //    | [] => b;
  //    | (x::xs) => x::app(xs,b);
  //    };
  // let rec revt(l,r) =
  //   switch(l) {
  //   | [] => r;
  //   | x::xs => revt(xs,x::r);
  //   };
  // let rev(l) = revt(l,[]);
  // let main(x:int) = {
  //   switch(rev([1,2,3])) {
  //   | h::_ => h;
  //   };
  //   };
  //let fac(n:int) = {
  //  if (n==0) 1 else (n*fac(n-1));
  //};
  //let main(x) = switch((12,34)) {
  //| (13,_) => x;
  //| (_,a) => x+a;
  //    | y => y+1;
  //  }
  //let main(x) = ({y:0>1, x:x==0}:point(bool));
  //let main(x) = x;
  //let main(x) = len(1::2::[]);
  //let main(x) = ((x,x):list('a));
  let main(x) = switch("a") {
      	      	|  "b" => 0;
		|  "a" => 1;
		|  "c" => 2;
		};
};
